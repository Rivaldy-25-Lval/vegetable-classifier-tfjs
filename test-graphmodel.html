<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test GraphModel Loading</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        #status { font-size: 18px; margin: 20px 0; font-weight: bold; }
        #log { 
            background: #000; 
            padding: 20px; 
            border: 2px solid #00ff00;
            white-space: pre-wrap;
            max-height: 600px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>TensorFlow.js - Try Building Model from Scratch</h1>
    <div id="status">⏳ Testing...</div>
    <div id="log"></div>

    <script>
        const logDiv = document.getElementById('log');
        const status = document.getElementById('status');

        function addLog(text) {
            logDiv.textContent += text + '\n';
            console.log(text);
        }

        async function testBuildModelFromWeights() {
            try {
                addLog('=== Testing: Build Model from Scratch ===\n');
                addLog('1. Checking TensorFlow.js...');
                addLog('   TensorFlow.js version: ' + tf.version.tfjs);
                addLog('   ✅ TensorFlow.js loaded!\n');

                addLog('2. Loading weights from binary files...');
                
                // Try to load the weights directly
                const baseUrl = window.location.origin;
                const weightsPath = `${baseUrl}/tfjs_models/`;
                
                addLog(`   Base path: ${weightsPath}`);
                
                // Fetch the model.json to get weight manifest
                const modelJsonResponse = await fetch(`${weightsPath}model.json?v=${Date.now()}`);
                const modelJson = await modelJsonResponse.json();
                
                addLog(`   ✅ Loaded model.json`);
                addLog(`   Format: ${modelJson.format}`);
                addLog(`   Generated by: ${modelJson.generatedBy}`);
                addLog(`   Weight files: ${modelJson.weightsManifest[0].paths.length}`);
                
                // Now try to manually build the model
                addLog('\n3. Building model from scratch...');
                
                const model = tf.sequential({
                    layers: [
                        tf.layers.conv2d({
                            inputShape: [128, 128, 3],
                            filters: 32,
                            kernelSize: 3,
                            activation: 'relu',
                            name: 'conv2d'
                        }),
                        tf.layers.maxPooling2d({
                            poolSize: 2,
                            name: 'max_pooling2d'
                        }),
                        tf.layers.conv2d({
                            filters: 64,
                            kernelSize: 3,
                            activation: 'relu',
                            name: 'conv2d_1'
                        }),
                        tf.layers.maxPooling2d({
                            poolSize: 2,
                            name: 'max_pooling2d_1'
                        }),
                        tf.layers.conv2d({
                            filters: 128,
                            kernelSize: 3,
                            activation: 'relu',
                            name: 'conv2d_2'
                        }),
                        tf.layers.maxPooling2d({
                            poolSize: 2,
                            name: 'max_pooling2d_2'
                        }),
                        tf.layers.conv2d({
                            filters: 128,
                            kernelSize: 3,
                            activation: 'relu',
                            name: 'conv2d_3'
                        }),
                        tf.layers.maxPooling2d({
                            poolSize: 2,
                            name: 'max_pooling2d_3'
                        }),
                        tf.layers.flatten({
                            name: 'flatten'
                        }),
                        tf.layers.dense({
                            units: 256,
                            activation: 'relu',
                            name: 'dense'
                        }),
                        tf.layers.dense({
                            units: 15,
                            activation: 'softmax',
                            name: 'dense_1'
                        })
                    ]
                });
                
                addLog('   ✅ Model architecture created!');
                addLog(`   Input shape: ${JSON.stringify(model.inputs[0].shape)}`);
                addLog(`   Output shape: ${JSON.stringify(model.outputs[0].shape)}`);
                addLog(`   Total parameters: ${model.countParams()}`);
                
                addLog('\n4. Now trying to load weights...');
                
                try {
                    // Try using tf.io.loadWeights
                    const weightsManifest = modelJson.weightsManifest;
                    const weightSpecs = weightsManifest[0].weights;
                    const weightData = await fetch(`${weightsPath}${weightsManifest[0].paths[0]}`).then(r => r.arrayBuffer());
                    const weightData2 = await fetch(`${weightsPath}${weightsManifest[0].paths[1]}`).then(r => r.arrayBuffer());
                    
                    addLog(`   ✅ Loaded weight file 1: ${weightData.byteLength} bytes`);
                    addLog(`   ✅ Loaded weight file 2: ${weightData2.byteLength} bytes`);
                    
                    // Combine weight data
                    const combinedWeights = new Uint8Array(weightData.byteLength + weightData2.byteLength);
                    combinedWeights.set(new Uint8Array(weightData), 0);
                    combinedWeights.set(new Uint8Array(weightData2), weightData.byteLength);
                    
                    addLog(`   Total weight data: ${combinedWeights.byteLength} bytes`);
                    
                    // Now we need to map weights to layers
                    addLog('\n5. Mapping weights to model layers...');
                    
                    // This is the tricky part - we need to set weights manually
                    let offset = 0;
                    const layerWeights = [];
                    
                    for (const spec of weightSpecs) {
                        const size = spec.shape.reduce((a, b) => a * b, 1);
                        const bytes = size * 4; // float32 = 4 bytes
                        
                        const weightBytes = combinedWeights.slice(offset, offset + bytes);
                        const weightArray = new Float32Array(weightBytes.buffer, weightBytes.byteOffset, size);
                        const tensor = tf.tensor(Array.from(weightArray), spec.shape, 'float32');
                        
                        layerWeights.push({
                            name: spec.name,
                            tensor: tensor,
                            shape: spec.shape
                        });
                        
                        offset += bytes;
                        addLog(`   - ${spec.name}: ${spec.shape.join('x')}`);
                    }
                    
                    addLog('\n   ✅ All weights parsed successfully!');
                    addLog(`   Total weight tensors: ${layerWeights.length}`);
                    
                    // Now set weights to model
                    addLog('\n6. Applying weights to model...');
                    
                    // Group weights by layer
                    const layerMap = new Map();
                    for (const w of layerWeights) {
                        const layerName = w.name.split('/')[1]; // Extract layer name from "sequential/conv2d/kernel"
                        if (!layerMap.has(layerName)) {
                            layerMap.set(layerName, []);
                        }
                        layerMap.set(layerName, w.tensor);
                    }
                    
                    addLog(`   Layers with weights: ${layerMap.size}`);
                    
                    status.textContent = '✅ Model built successfully! (Weights loaded but not applied yet)';
                    status.style.color = 'green';
                    
                    addLog('\n=== PARTIAL SUCCESS ===');
                    addLog('Model architecture created and weights loaded.');
                    addLog('However, applying weights requires exact mapping which is complex.');
                    addLog('\nThe main issue is that the original model.json from Keras 3.x');
                    addLog('is not fully compatible with TensorFlow.js 4.20.0 LayersModel format.');
                    
                } catch (weightError) {
                    addLog('   ❌ Weight loading error: ' + weightError.message);
                    throw weightError;
                }
                
            } catch (error) {
                addLog('\n❌ ERROR:');
                addLog(error.toString());
                addLog(error.stack);
                status.textContent = '❌ Test failed';
                status.style.color = 'red';
            }
        }

        // Start test when page loads
        window.onload = () => {
            testBuildModelFromWeights();
        };
    </script>
</body>
</html>
